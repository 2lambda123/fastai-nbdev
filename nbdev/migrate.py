# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/15_migrate.ipynb.

# %% auto 0
__all__ = ['MigrateProc', 'fp_nb_fm', 'fp_md_fm', 'migrate_nb', 'migrate_md', 'nbdev_migrate']

# %% ../nbs/API/15_migrate.ipynb 2
from .process import *
from .frontmatter import *
from .frontmatter import _fm2dict, _re_fm_md
from .processors import *
from .config import get_config, read_nb
from .sync import write_nb
from .showdoc import show_doc
from fastcore.all import *
import shutil

# %% ../nbs/API/15_migrate.ipynb 6
def _cat_slug(fmdict):
    "Get the partial slug from the category front matter."
    return '/' + '/'.join(sorted(fmdict.get('categories', '')))

# %% ../nbs/API/15_migrate.ipynb 8
def _file_slug(fname): 
    "Get the partial slug from the filename."
    p = Path(fname)
    dt = '/'+p.name[:10].replace('-', '/')+'/'
    return dt + p.stem[11:]    

# %% ../nbs/API/15_migrate.ipynb 10
def _replace_fm(d:dict, # dictionary you wish to conditionally change
                k:str,  # key to check 
                val:str,# value to check if d[k] == v
                repl_dict:dict #dictionary that will be used as a replacement 
               ):
    "replace key `k` in dict `d` if d[k] == val with `repl_dict`"
    if str(d.get(k, '')).lower().strip() == str(val.lower()).strip():
        d.pop(k)
        d = merge(d, repl_dict)
    return d

def _fp_fm(d):
    "create aliases for fastpages front matter to match Quarto front matter."
    d = _replace_fm(d, 'search_exclude', 'true', {'search':'false'})
    d = _replace_fm(d, 'hide', 'true', {'draft': 'true'})
    return d

# %% ../nbs/API/15_migrate.ipynb 11
def _fp_image(d):
    "Correct path of fastpages images to reference the local directory."
    prefix = 'images/copied_from_nb/'
    if d.get('image', '').startswith(prefix): d['image'] = d['image'].replace(prefix, '')
    return d

# %% ../nbs/API/15_migrate.ipynb 12
def _is_jekyll_post(path): return bool(re.search(r'^\d{4}-\d{2}-\d{2}-', Path(path).name))

def _fp_convert(fm:dict, path:Path):
    "Make fastpages frontmatter Quarto complaint and add redirects."
    if _is_jekyll_post(path):
        fm = compose(_fp_fm, _fp_image)(fm)
        if 'permalink' in fm: fm['aliases'] = [f"{fm['permalink'].strip()}"]
        else: fm['aliases'] = [f'{_cat_slug(fm) + _file_slug(path)}']
    return fm

# %% ../nbs/API/15_migrate.ipynb 15
class MigrateProc(Processor):
    def begin(self): 
        self.nb.frontmatter_ = _fp_convert(self.nb.frontmatter_, self.path)
        if getattr(first(self.nb.cells), 'cell_type', None) == 'raw': del self.nb.cells[0]
        insertfm(self.nb, self.nb.frontmatter_)

def fp_nb_fm(path, overwrite=True):
    "Migrate fastpages front matter in notebooks to a raw cell."
    nbp = NBProcessor(path, procs=[FrontmatterProc, MigrateProc])
    nbp.process()
    if overwrite: write_nb(nbp.nb, path)
    return nbp.nb

# %% ../nbs/API/15_migrate.ipynb 22
def fp_md_fm(path):
    "Make fastpages front matter in markdown files quarto compliant."
    p = Path(path)
    md = p.read_text()
    fm = _fm2dict(md, nb=False)
    if fm:
        fm = _fp_convert(fm, path)
        return _re_fm_md.sub(dict2fm(fm), md)
    else: return md 

# %% ../nbs/API/15_migrate.ipynb 30
_alias = merge({k:'code-fold: true' for k in ['collapse', 'collapse_input', 'collapse_hide']}, {'collapse_show':'code-fold: show'})
def _subv1(s): return _alias.get(s, s)

# %% ../nbs/API/15_migrate.ipynb 31
def _re_v1():
    d = ['default_exp', 'export', 'exports', 'exporti', 'hide', 'hide_input', 'collapse_show', 'collapse',
         'collapse_hide', 'collapse_input', 'hide_output',  'default_cls_lvl']
    d += L(get_config().tst_flags).filter()
    d += [s.replace('_', '-') for s in d] # allow for hyphenated version of old directives
    _tmp = '|'.join(list(set(d)))
    return re.compile(f"^[ \f\v\t]*?(#)\s*({_tmp})(?!\S)", re.MULTILINE)

def _repl_directives(code_str): 
    def _fmt(x): return f"#| {_subv1(x[2].replace('-', '_').strip())}"
    return _re_v1().sub(_fmt, code_str)

# %% ../nbs/API/15_migrate.ipynb 35
def _listify_src(cell): 
    src = cell.get('source')
    return src.splitlines() if isinstance(src, str) else src.copy() if src else None

# %% ../nbs/API/15_migrate.ipynb 36
def _repl_v1dir(cell):
    "Replace nbdev v1 with v2 directives."
    if cell.get('source') and cell.get('cell_type') == 'code':
        ss = cell['source'].splitlines()
        first_code = first_code_ln(ss, re_pattern=_re_v1())
        if not first_code: first_code = len(ss)
        if not ss: pass
        else: cell['source'] = '\n'.join([_repl_directives(c) for c in ss[:first_code]] + ss[first_code:])

# %% ../nbs/API/15_migrate.ipynb 39
_re_callout = re.compile(r'^>\s(Warning|Note|Important|Tip):(.*)', flags=re.MULTILINE)
def _co(x): return ":::{.callout-"+x[1].lower()+"}\n\n" + f"{x[2].strip()}\n\n" + ":::"
def _convert_callout(s): 
    "Convert nbdev v1 to v2 callouts."
    return _re_callout.sub(_co, s)

# %% ../nbs/API/15_migrate.ipynb 45
def _repl_v1callouts(cell):
    "Replace nbdev v1 with v2 callouts."
    if cell.get('source') and cell.get('cell_type') == 'markdown':
        cell['source'] = _convert_callout(cell['source'])

# %% ../nbs/API/15_migrate.ipynb 46
def migrate_nb(path, overwrite=True):
    "Migrate Notebooks from nbdev v1 and fastpages."
    nbp = NBProcessor(path, procs=[FrontmatterProc, MigrateProc, _repl_v1callouts, _repl_v1dir])
    nbp.process()
    if overwrite: write_nb(nbp.nb, path)
    return nbp.nb

# %% ../nbs/API/15_migrate.ipynb 47
def migrate_md(path, overwrite=True):
    "Migrate Markdown Files from fastpages."
    txt = fp_md_fm(path)
    if overwrite: path.write_text(txt)
    return txt

# %% ../nbs/API/15_migrate.ipynb 48
@call_parse
def nbdev_migrate(
    path:str=None, # A path or glob containing notebooks and markdown files to migrate
    no_skip:bool=False, # Do not skip directories beginning with an underscore
):
    "Convert all markdown and notebook files in  and callouts in `fname` from v1 to v2"
    _skip_re = None if no_skip else '^[_.]'
    if path is None: path = get_config().nbs_path
    for f in globtastic(path, file_re='(.ipynb$)|(.md$)', skip_folder_re=_skip_re, func=Path):
        if f.name.endswith('.ipynb'): migrate_nb(f)
        if f.name.endswith('.md'): migrate_md(f)        
