# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04b_doclinks.ipynb.

# %% auto 0
__all__ = ['DocLinks', 'get_patch_name', 'build_modidx', 'nbglob', 'nbprocess_export']

# %% ../nbs/04b_doclinks.ipynb 3
from .read import *
from .maker import *
from .export import *
from .imports import *

from fastcore.script import *
from fastcore.imports import *
from fastcore.utils import *

import ast,contextlib
from pprint import pformat
from urllib.parse import urljoin

# %% ../nbs/04b_doclinks.ipynb 5
def _mod_fn2name(fn):
    "Convert filename `fn` to its module name"
    return '.'.join(str(Path(fn).with_suffix('')).split('/'))

class DocLinks:
    "Create a module symbol index from a python source file"
    def __init__(self, mod_fn, doc_func, dest_fn, mod_name=None):
        mod_fn,dest_fn = Path(mod_fn),Path(dest_fn)
        if mod_name is None: mod_name = _mod_fn2name(
            mod_fn.resolve().relative_to(dest_fn.parent.parent.resolve()))
        store_attr()
        if self.dest_fn.exists(): self.d = exec_local(self.dest_fn.read_text(), 'd')
        else: self.d = dict(syms={}, settings={}) 

# %% ../nbs/04b_doclinks.ipynb 12
@patch
def write_nbprocess_idx(self:DocLinks):
    "Create nbprocess documentation index file`"
    res = pformat(self.d, width=160, indent=2, compact=True, sort_dicts=False)
    self.dest_fn.write_text("# Autogenerated by nbprocess\n\nd = " + res)

# %% ../nbs/04b_doclinks.ipynb 15
def _decor_id(d):
    if hasattr(d, 'id'): return d.id
    return d.func.value.id

def _all_or_exports(fn):
    code = Path(fn).read_text()
    trees = L(ast.parse(code).body)
    res = read_var(code, '__all__')
    return L(retr_exports(trees) if res is None else res),trees

def _is_patch(o): return any([1 for d in o.decorator_list if _decor_id(d).startswith('patch')])

def _pat_name(o):
    try: return f'{o.args.args[0].annotation.id}.{o.name}'
    except AttributeError: return None 

def _exp_meths(tree):
    return L(f"{tree.name}.{o.name}" for o in tree.body
             if isinstance(o,(ast.FunctionDef,ast.AsyncFunctionDef)) and o.name[0]!='_')



# %% ../nbs/04b_doclinks.ipynb 16
def get_patch_name(tree):
    "If a method is defined with @patch, get fully qualified name."
    if  isinstance(tree, (ast.FunctionDef,ast.AsyncFunctionDef)) and _is_patch(tree):
        return f'{tree.args.args[0].annotation.id}.{tree.name}'
    else: return None

# %% ../nbs/04b_doclinks.ipynb 17
@patch
def update_syms(self:DocLinks):
    exp,trees = _all_or_exports(self.mod_fn)
    exp_class = trees.filter(lambda o: isinstance(o, ast.ClassDef) and o.name in exp)
    exp += exp_class.map(_exp_meths).concat()
    exp += L(get_patch_name(o) for o in trees).filter()
    exp = exp.map(f"{self.mod_name}.{{}}")
    self.d['syms'][self.mod_name] = exp.map_dict(partial(self.doc_func, self.mod_name))

# %% ../nbs/04b_doclinks.ipynb 20
@patch
def build_index(self:DocLinks):
    self.update_syms()
    self.d['settings'] = dict(**get_config().d)
    self.write_nbprocess_idx()

# %% ../nbs/04b_doclinks.ipynb 22
def _doc_link(url, mod, sym=None):
    res = urljoin(url, remove_prefix(mod, get_config()['lib_name']+"."))
    if sym: res += "#" + remove_prefix(sym, mod+".")
    return res

# %% ../nbs/04b_doclinks.ipynb 24
def build_modidx():
    "Create _modidx.py"
    dest = config_key('lib_path')
    if os.environ.get('IN_TEST',0): return
    _fn = dest/'_modidx.py'
    nbs_path = config_key('nbs_path')
    files = globtastic(nbs_path)
    with contextlib.suppress(FileNotFoundError): _fn.unlink()
    cfg = get_config()
    doc_func = partial(_doc_link, urljoin(cfg.doc_host,cfg.doc_baseurl))
    for file in dest.glob("**/*.py"):
        if file.name[0]!='_': DocLinks(file, doc_func, _fn).build_index()

# %% ../nbs/04b_doclinks.ipynb 25
def nbglob(path=None, recursive=True, symlinks=True, file_glob='*.ipynb',
    file_re=None, folder_re=None, skip_file_glob=None, skip_file_re=None, skip_folder_re='^[_.]', key='nbs_path'):
    "Find all files in a directory matching an extension given a `config_key`."
    path = Path(path or config_key(key))
    if recursive is None: recursive=get_config().get('recursive', 'False').lower() == 'true'
    if not recursive: skip_folder_re='.'
    return globtastic(path, symlinks=symlinks, file_glob=file_glob, file_re=file_re,
        folder_re=folder_re, skip_file_glob=skip_file_glob, skip_file_re=skip_file_re, skip_folder_re=skip_folder_re)

# %% ../nbs/04b_doclinks.ipynb 26
@call_parse
def nbprocess_export(
    path:str=None, # path or filename
    recursive:bool=True, # search subfolders
    symlinks:bool=True, # follow symlinks?
    file_glob:str='*.ipynb', # Only include files matching glob
    file_re:str=None, # Only include files matching regex
    folder_re:str=None, # Only enter folders matching regex
    skip_file_glob:str=None, # Skip files matching glob
    skip_file_re:str=None, # Skip files matching regex
    skip_folder_re:str='^[_.]' # Skip folders matching regex
):
    if os.environ.get('IN_TEST',0): return
    files = nbglob(path, recursive, symlinks, file_glob, file_re, folder_re, skip_file_glob, skip_file_re, skip_folder_re=skip_folder_re)
    files.map(nb_export)
    add_init(get_config().path('lib_path'))
    build_modidx()
