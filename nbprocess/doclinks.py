# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04a_doclinks.ipynb.

# %% auto 0
__all__ = ['DocLinks', 'build_modidx']

# %% ../nbs/04a_doclinks.ipynb 3
from .read import *
from .export import *
from .maker import *
from .imports import *
from .cli import *

from fastcore.script import *
from fastcore.imports import *
from fastcore.utils import *

import ast,contextlib
from pprint import pformat
from urllib.parse import urljoin

# %% ../nbs/04a_doclinks.ipynb 5
def _mod_fn2name(fn):
    "Convert filename `fn` to its module name"
    return '.'.join(str(Path(fn).with_suffix('')).split('/'))

class DocLinks:
    "Create a module symbol index from a python source file"
    def __init__(self, mod_fn, doc_func, dest_fn, mod_name=None):
        mod_fn,dest_fn = Path(mod_fn),Path(dest_fn)
        if mod_name is None: mod_name = _mod_fn2name(
            mod_fn.resolve().relative_to(dest_fn.parent.parent.resolve()))
        store_attr()
        if self.dest_fn.exists(): self.d = exec_local(self.dest_fn.read_text(), 'd')
        else: self.d = dict(syms={}, settings={}) 

# %% ../nbs/04a_doclinks.ipynb 12
@patch
def write_nbprocess_idx(self:DocLinks):
    "Create nbprocess documentation index file`"
    self.dest_fn.write_text("# Autogenerated by nbprocess\n\nd = "
                            + pformat(self.d, width=160, indent=2, compact=True, sort_dicts=False))

# %% ../nbs/04a_doclinks.ipynb 15
def _decor_id(d):
    if hasattr(d, 'id'): return d.id
    return d.func.value.id

def _all_or_exports(fn):
    code = Path(fn).read_text()
    trees = L(ast.parse(code).body)
    res = read_var(code, '__all__')
    return L(retr_exports(trees) if res is None else res),trees

def _is_patch(o): return any([1 for d in o.decorator_list if _decor_id(d).startswith('patch')])

def _pat_name(o):
    try: return f'{o.args.args[0].annotation.id}.{o.name}'
    except AttributeError: return None 

def _exp_meths(tree):
    return L(f"{tree.name}.{o.name}" for o in tree.body
             if isinstance(o,(ast.FunctionDef,ast.AsyncFunctionDef)) and o.name[0]!='_')

# %% ../nbs/04a_doclinks.ipynb 16
@patch
def update_syms(self:DocLinks):
    exp,trees = _all_or_exports(self.mod_fn)
    exp_class = trees.filter(lambda o: isinstance(o, ast.ClassDef) and o.name in exp)
    exp += exp_class.map(_exp_meths).concat()
    pats = L(o for o in trees
       if isinstance(o,(ast.FunctionDef,ast.AsyncFunctionDef)) and _is_patch(o))
    pats = L(f'{o.args.args[0].annotation.id}.{o.name}' for o in pats)
    exp += pats.filter()
    exp = exp.map(f"{self.mod_name}.{{}}")
    self.d['syms'][self.mod_name] = exp.map_dict(partial(self.doc_func, self.mod_name))

# %% ../nbs/04a_doclinks.ipynb 19
@patch
def build_index(self:DocLinks):
    self.update_syms()
    self.d['settings'] = dict(**get_config().d)
    self.write_nbprocess_idx()

# %% ../nbs/04a_doclinks.ipynb 21
def _doc_link(url, mod, sym=None):
    res = urljoin(url, mod)
    if sym: res += "#" + remove_prefix(sym, mod+".")
    return res

# %% ../nbs/04a_doclinks.ipynb 22
@call_parse
def build_modidx():
    "Create _modidx.py"
    dest = config_key('lib_path')
    if os.environ.get('IN_TEST',0): return
    _fn = dest/'_modidx.py'
    nbs_path = config_key('nbs_path')
    files = globtastic(nbs_path)
    with contextlib.suppress(FileNotFoundError): _fn.unlink()
    cfg = get_config()
    doc_func = partial(_doc_link, urljoin(cfg.doc_host,cfg.doc_baseurl))
    for file in dest.glob("**/*.py"):
        if file.name[0]!='_': DocLinks(file, doc_func, _fn).build_index()
