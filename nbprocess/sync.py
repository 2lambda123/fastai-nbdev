# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_sync.ipynb (unless otherwise specified).

__all__ = ['absolute_import', 'nbprocess_update_lib']

# Cell
from .read import *
from .export import *

from .imports import *
from fastcore.script import *

import nbformat,ast
from nbformat.sign import NotebookNotary

# Cell
def absolute_import(name, fname, level):
    "Unwarps a relative import in `name` according to `mod_name`"
    if not level: return name
    mods = fname.split(os.path.sep)
    if not name: return '.'.join(mods)
    return '.'.join(mods[:len(mods)-level+1]) + f".{name}"

# Cell
_re_import = re.compile("from\s+\S+\s+import\s+\S")

def _to_absolute(code, libname):
    if not _re_import.search(code): return code
    res = update_import(code, ast.parse(code).body, libname, absolute_import)
    if not res: return code
    return ''.join(res)

def _update_lib(nbname, nb_locs):
    libname = Config().lib_name
    nbtxt = Path(nbname).read_text()
    nb = nbformat.reads(nbtxt, as_version=4)
    for nbn,cellid,code in nb_locs:
        assert nbn==nbname,(nbn,nbname)
        code = code[code.find("\n")+1:]
        nb.cells[int(cellid)].source = _to_absolute(code, libname)

    NotebookNotary().sign(nb)
    nbformat.write(nb, 'tmp/tmp.ipynb', version=4)

# Cell
@call_parse
def nbprocess_update_lib(fname:Param("A python module name to convert", str)):
    "Propagates any change in the modules matching `fname` to the notebooks that created them"
    if os.environ.get('IN_TEST',0): return
    fname = Path(fname)
    code = fname.read_text()
    split_str = "\n#nbprocess_cell "
    code_cells = code.split(split_str)[1:]
    locs = L(s.splitlines()[0].split()+[s.strip("\n")]
             for s in code_cells if not s.startswith('auto '))
    for nbname,nb_locs in groupby(locs, itemgetter(0)).items(): _update_lib(nbname, nb_locs)