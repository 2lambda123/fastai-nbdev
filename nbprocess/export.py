# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_export.ipynb (unless otherwise specified).

__all__ = ['extract_comments', 'NotebookProcessor', 'ExportModuleProcessor', 'nb_export', 'nbs_export']

# Cell
from .read import *
from .maker import *
from .imports import *

from fastcore.script import *
from fastcore.imports import *
from fastcore.xtras import *

from collections import defaultdict
from pprint import pformat
from inspect import signature,Parameter
import ast,contextlib,copy

# Cell
def extract_comments(ss):
    "Take leading comments from lines of code in `ss`, remove `#`, and split"
    ss = ss.splitlines()
    first_code = first(i for i,o in enumerate(ss) if not o.strip() or re.match('\s*[^#\s]', o))
    return L((s.strip()[1:]).strip().split() for s in ss[:first_code]).filter()

# Cell
class NotebookProcessor:
    "Base class for nbprocess notebook processors"
    def __init__(self, path, debug=False): self.nb,self.path,self.debug = read_nb(path),Path(path),debug

# Cell
@functools.lru_cache(maxsize=None)
def _param_count(f):
    "Number of parameters accepted by function `f`"
    params = list(signature(f).parameters.values())
    # If there's a `*args` then `f` can take as many params as neede
    if first(params, lambda o: o.kind==Parameter.VAR_POSITIONAL): return 99
    return len([o for o in params if o.kind in (Parameter.POSITIONAL_ONLY,Parameter.POSITIONAL_OR_KEYWORD)])

# Cell
@patch
def process_comment(self:NotebookProcessor, cell_type, comment, idx):
    cmd,*args = comment
    self.comment,self.idx = comment,idx
    cmd = f"{cmd}_{cell_type}"
    if self.debug: print(cmd, args)
    f = getattr(self, cmd, None)
    if not f or _param_count(f)<len(args): return True
    return f(*args)

# Cell
@patch
def process_cell(self:NotebookProcessor, cell):
    comments = extract_comments(cell.source)
    self.cell = cell
    if not comments: return
    keeps = [self.process_comment(cell.cell_type, comment, i)
             for i,comment in enumerate(comments)]
    self.cell.source = ''.join([o for i,o in enumerate(self.cell.source.splitlines(True))
                                if i>=len(keeps) or keeps[i]])

# Cell
@patch
def process(self:NotebookProcessor):
    "Process all cells with `process_cell` and replace `self.nb.cells` with result"
    for i in range_of(self.nb.cells): self.process_cell(self.nb.cells[i])

# Cell
class ExportModuleProcessor(NotebookProcessor):
    "A `NotebookProcessor` which exports code to a module"
    def __init__(self, path, dest, mod_maker=ModuleMaker, debug=False):
        dest = Path(dest)
        store_attr()
        super().__init__(path,debug=debug)

    def process(self):
        self.default_exp,self.modules,self.in_all = None,defaultdict(L),defaultdict(L)
        super().process()

# Cell
@patch
def default_exp_code(self:ExportModuleProcessor, exp_to): self.default_exp = exp_to

# Cell
@patch
def exporti_code(self:ExportModuleProcessor, exp_to=None):
    "Export a cell, without including the definition in `__all__`"
    self.modules[ifnone(exp_to, '#')].append(self.cell)

# Cell
@patch
def export_code(self:ExportModuleProcessor, exp_to=None):
    "Export a cell, adding the definition in `__all__`"
    self.exporti_code(exp_to)
    self.in_all[ifnone(exp_to, '#')].append(self.cell)

# Cell
@patch
def create_modules(self:ExportModuleProcessor):
    "Create module(s) from notebook"
    self.process()
    for mod,cells in self.modules.items():
        all_cells = self.in_all[mod]
        name = self.default_exp if mod=='#' else mod
        mm = self.mod_maker(dest=self.dest, name=name, nb_path=self.path, is_new=mod=='#')
        mm.make(cells, all_cells)

# Cell
def nb_export(nbname, lib_name=None):
    if lib_name is None: lib_name = get_config().lib_name
    ExportModuleProcessor(nbname, lib_name).create_modules()

# Cell
@call_parse
def nbs_export(
    path:(Path,str)='.', # path or filename
    recursive:bool=True, # search subfolders
    symlinks:bool=True, # follow symlinks?
    file_glob:str='*.ipynb', # Only include files matching glob
    file_re:str=None, # Only include files matching regex
    folder_re:str=None, # Only enter folders matching regex
    skip_file_glob:str=None, # Skip files matching glob
    skip_file_re:str=None, # Skip files matching regex
    skip_folder_re:str='^[_.]' # Skip folders matching regex
):
    if os.environ.get('IN_TEST',0): return
    path = Path(path)
    if not recursive: skip_folder_re='.'
    if path.is_file(): files = [path]
    globtastic(path, symlinks=symlinks, file_glob=file_glob, file_re=file_re,
        folder_re=folder_re, skip_file_glob=skip_file_glob, skip_file_re=skip_file_re, skip_folder_re=skip_folder_re
        ).map(nb_export)