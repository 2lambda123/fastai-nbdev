# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_merge.ipynb.

# %% auto 0
__all__ = ['conf_re', 'get_md_cell', 'nbdev_fix_merge']

# %% ../nbs/05_merge.ipynb 2
from .imports import *
from .read import *
from fastcore.script import *

# %% ../nbs/05_merge.ipynb 11
_BEG,_MID,_END = '<'*7,'='*7,'>'*7
conf_re = re.compile(rf'^{_BEG}\s+(\S+)\n(.*?)\n{_MID}\n(.*?)^{_END}\s+(\S+)$', re.MULTILINE|re.DOTALL)

def _unpatch_f(before, cb1, cb2, c, r):
    if cb1 is not None and cb1 != cb2: raise Exception(f'Branch mismatch: {cb1}/{cb2}')
    r.append(before)
    r.append(c)
    return cb2

def _unpatch_res(r, last): return dict2nb(json.loads(''.join(r+[last])))

def _unpatch(s):
    conflicts = conf_re.split(s)
    r1,r2 = [],[]
    c1b,c2b = None,None
    *main,last = conflicts
    for before,c1_branch,c1,c2,c2_branch in chunked(main, 5):
        c1b = _unpatch_f(before, c1b, c1_branch, c1, r1)
        c2b = _unpatch_f(before, c2b, c2_branch, c2, r2)
    return _unpatch_res(r1, last),_unpatch_res(r2, last)

# %% ../nbs/05_merge.ipynb 17
def get_md_cell(txt):
    "A markdown cell with `txt`"
    return '''  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "%s"
   ]
  },''' % txt

# %% ../nbs/05_merge.ipynb 19
_re_conflict = re.compile(r'^<<<<<<<', re.MULTILINE)

# %% ../nbs/05_merge.ipynb 22
@call_parse
def nbdev_fix_merge(fname:str, # notebook filename to fix
                    trust_us:bool=True): # use our outputs/metadata instead of theirs
    "Fix merge conflicts in notebook `fname`"
    fname=Path(fname)
    shutil.copy(fname, fname.with_suffix('.ipynb.bak'))
    raw_text = fname.read_text()
    if not added: print("Successfully merged conflicts!")
    else: print("One or more conflict remains in the notebook, please inspect manually.")
