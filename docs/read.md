<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

# nbprocess.read
- Reading a notebook, and initial bootstrapping for notebook exporting
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
import time,nbclient,tempfile
from IPython.display import Markdown
from pprint import pformat,pprint
```

</div>

</div>

## Reading and executing notebooks

A notebook is just a json file:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
minimal_fn = Path('../tests/minimal.ipynb')
minimal_txt = minimal_fn.read_json()
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
def _display_json(d):
    "Formatter to reduce vertical space used by JSON display"
    s = pformat(d, indent=2, width=120, compact=True, sort_dicts=False)
    return Markdown(f"```python\n{s}\n```")
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
_display_json(minimal_txt)
```

</div>
<div class="output_area" markdown="1">




```python
{ 'cells': [ {'cell_type': 'markdown', 'metadata': {}, 'source': ['# A minimal notebook']},
             { 'cell_type': 'code',
               'execution_count': 1,
               'metadata': {},
               'outputs': [ { 'data': {'text/plain': ['2']},
                              'execution_count': 1,
                              'metadata': {},
                              'output_type': 'execute_result'}],
               'source': ['# Do some arithmetic\n', '1+1']},
             {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': []}],
  'metadata': { 'kernelspec': {'display_name': 'Python 3 (ipykernel)', 'language': 'python', 'name': 'python3'},
                'language_info': { 'codemirror_mode': {'name': 'ipython', 'version': 3},
                                   'file_extension': '.py',
                                   'mimetype': 'text/x-python',
                                   'name': 'python',
                                   'nbconvert_exporter': 'python',
                                   'pygments_lexer': 'ipython3',
                                   'version': '3.9.5'}},
  'nbformat': 4,
  'nbformat_minor': 4}
```



</div>

</div>

The important bit for us is the `cells`:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
_display_json(minimal_txt['cells'])
```

</div>
<div class="output_area" markdown="1">




```python
[ {'cell_type': 'markdown', 'metadata': {}, 'source': ['# A minimal notebook']},
  { 'cell_type': 'code',
    'execution_count': 1,
    'metadata': {},
    'outputs': [{'data': {'text/plain': ['2']}, 'execution_count': 1, 'metadata': {}, 'output_type': 'execute_result'}],
    'source': ['# Do some arithmetic\n', '1+1']},
  {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': []}]
```



</div>

</div>

The second cell here is a `code` cell, however it contains no outputs, because it hasn't been executed yet. To execute a notebook, we first need to convert it into a format suitable for `nbclient` (which expects some `dict` keys to be available as attrs, and some available as regular `dict` keys). Normally, `nbformat` is used for this step, but it's rather slow and inflexible, so we'll write our own function based on `fastcore`'s handy `dict2obj`, which makes all keys available as both attrs *and* keys.

We use an `AttrDict` subclass which has some basic functionality for accessing notebook cells.

We can now convert our JSON into this `nbclient`-compatible format...
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
minimal = dict2nb(minimal_txt)
```

</div>

</div>

...and execute it:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
nbclient.execute(minimal);
```

</div>

</div>

One nice feature of the output of `dict2nb` is that we can still use it as a `dict`, so `_display_json` still works as before. We can see that the cell has been executed, and the output added back to the `nb`:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
cell = minimal.cells[1]
print(cell)
```

</div>
<div class="output_area" markdown="1">

    # Do some arithmetic
    1+1


</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
_display_json(cell.outputs)
```

</div>
<div class="output_area" markdown="1">




```python
[{'output_type': 'execute_result', 'metadata': {}, 'data': {'text/plain': '2'}, 'execution_count': 1}]
```



</div>

</div>

The abstract syntax tree of source code cells is available in the `parsed_` property:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
cell.parsed_()
```

</div>
<div class="output_area" markdown="1">




    [<ast.Expr at 0x7f15e40e68e0>]



</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
cell.parsed_()[0].value.op
```

</div>
<div class="output_area" markdown="1">




    <ast.Add at 0x7f161dc2a730>



</div>

</div>

Since loading JSON and converting to an NB is something we'll do a lot, we'll create a shortcut function for it:
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
minimal = read_nb(minimal_fn)
print(minimal.cells[0])
```

</div>
<div class="output_area" markdown="1">

    # A minimal notebook


</div>

</div>

## Config

nbprocess uses a `settings.ini` file in the root of the project to store all configuration details. This file is in `ConfigParser` format, and can be read and written conveniently using fastcore's `Config` class.

This is a wrapper for `fastcore`'s `save_config_file` which sets some `nbprocess` defaults. It is also installed as a CLI command.

`get_config` searches for `settings.ini` in the current directory, and then in all parent directories, stopping when it is found.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
nbprocess_create_config('fastai', path='..', nbs_path='nbs', tst_flags='tst', cfg_name='test_settings.ini')
cfg = get_config('test_settings.ini')
test_eq(cfg.lib_name, 'nbprocess')
test_eq(cfg.git_url, "https://github.com/fastai/nbprocess/tree/master/")
cwd = Path.cwd()
test_eq(cfg.config_path, cwd.parent.absolute())
test_eq(cfg.path('lib_path'), cwd.parent/'nbprocess')
test_eq(cfg.path('nbs_path'), cwd)
test_eq(cfg.path('doc_path'), cwd.parent/'docs')
```

</div>

</div>

##  Exporting a basic module

Python modules require a `__init.py__` file in all directories that are modules. We assume that all directories containing a python file (including in subdirectories of any depth) is a module, and therefore add a `__init__.py` to each.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
with tempfile.TemporaryDirectory() as d:
    d = Path(d)
    (d/'a/b').mkdir(parents=True)
    (d/'a/b/f.py').touch()
    (d/'a/c').mkdir()
    add_init(d)
    assert not (d/'a/c'/_init).exists(), "Should not add init to dir without py file"
    for e in [d, d/'a', d/'a/b']: assert (e/_init).exists(),f"Missing init in {e}"
```

</div>

</div>

This is a simple exporter with just enough functionality to correctly export this notebook, in order to bootstrap the creation of nbprocess itself.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```python
#skip
path = Path('../nbprocess')
(path/'read.py').unlink(missing_ok=True)

add_init(path)
basic_export_nb("00_read.ipynb", 'read.py')

g = exec_new('from nbprocess import read')
assert g['read'].add_init
assert 'add_init' in g['read'].__all__
```

</div>

</div>
