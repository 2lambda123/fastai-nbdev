<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

# nbprocess.maker
- Create one or more modules from selected notebook cells
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
from fastcore.test import *
from pdb import set_trace
from importlib import reload
```

</div>

</div>

## Variable helpers

These functions let us find and modify the definitions of variables in python modules.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
t = '''a_=(1,
  2,
  3)

b_=3'''
test_eq(find_var(t.splitlines(), 'a_'), (0,3))
test_eq(find_var(t.splitlines(), 'b_'), (4,5))
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
test_eq(read_var(t, 'a_'), (1,2,3))
test_eq(read_var(t, 'b_'), 3)
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
g = exec_new(t)
test_eq((g['a_'],g['b_']), ((1,2,3),3))
t2 = update_var('a_', lambda o:0, code=t)
exec(t2, g)
test_eq((g['a_'],g['b_']), (0,3))
t3 = update_var('b_', lambda o:0, code=t)
exec(t3, g)
test_eq((g['a_'],g['b_']), ((1,2,3),0))
```

</div>

</div>

In order to export a notebook, we need an way to create a Python file. `ModuleMaker` fills that role. Pass in the directory where you want to module created, the name of the module, the path of the notebook source, and set `is_new` to `True` if this is a new file being created (rather than an existing file being added to). The location of the saved module will be in `fname`.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
mm = ModuleMaker(dest='tmp', name='test.testing', nb_path=Path.cwd()/'01_export.ipynb', is_new=True)
mm.fname
```

</div>
<div class="output_area" markdown="1">




    Path('tmp/test/testing.py')



</div>

</div>

We want to add an `__all__` to the top of the exported module. This methods autogenerates it from all code in `cells`.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
nb = make_code_cells("from __future__ import print_function", "def a():...", "def b():...",
                      "c=d=1", "_f=1", "_g=1", "_all_=['_g']", "@patch\ndef h(self:ca):...")
test_eq(set(mm.make_all(nb)), set(['a','b','c','d', '_g']))
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
test_eq(relative_import('nbprocess.core', "xyz"), 'nbprocess.core')
test_eq(relative_import('nbprocess.core', 'nbprocess'), '.core')
_p = Path('fastai')
test_eq(relative_import('fastai.core', _p/'vision'), '..core')
test_eq(relative_import('fastai.core', _p/'vision/transform'), '...core')
test_eq(relative_import('fastai.vision.transform', _p/'vision'), '.transform')
test_eq(relative_import('fastai.notebook.core', _p/'data'), '..notebook.core')
test_eq(relative_import('fastai.vision', _p/'vision'), '.')
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
ss = "from nbprocess.export import *\nfrom nbprocess.a.b import *"
cell = make_code_cells([ss])[0]
cell.import2relative('nbprocess')
test_eq(cell.source, 'from .export import *\nfrom .a.b import *')

cell = make_code_cells([ss])[0]
cell.import2relative('nbprocess/a')
test_eq(cell.source, 'from ..export import *\nfrom .b import *')
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
def _print_file(fname, mx=None): print(Path(fname).read_text().strip()[:ifnone(mx,9999)])
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
cells = make_code_cells("from __future__ import print_function", "#export\ndef a(): ...", "def b(): ...")
mm.make(cells, L([cells[1]]))
print(Path('tmp/test/testing.py').read_text())
```

</div>
<div class="output_area" markdown="1">

    # AUTOGENERATED! DO NOT EDIT! File to edit: ../01_export.ipynb.
    
    # %% ../01_export.ipynb 0
    from __future__ import print_function
    
    # %% auto 0
    __all__ = ['a']
    
    # %% ../01_export.ipynb 2
    #export
    def a(): ...
    
    # %% ../01_export.ipynb 3
    def b(): ...
    


</div>

</div>

Pass `all_cells=[]` if you don't want any `__all__` added.

If `is_new=False` then the additional definitions are added to the bottom, and any existing `__all__` is updated with the newly-added symbols.
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
c2 = make_code_cells("def c(): ...", "def d(): ...")
mm = ModuleMaker(dest='tmp', name='test.testing', nb_path=Path.cwd()/'01_export.ipynb', is_new=False)
mm.make(c2, c2)
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
g = exec_new('from tmp.test.testing import *')
for s in "a c d".split(): assert s in g, s
assert 'b' not in g
assert g['a']() is None
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
path = Path('../nbprocess')
(path/'read.py').unlink(missing_ok=True)
(path/'maker.py').unlink(missing_ok=True)

add_init(path)
cfg = get_config()
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
basic_export_nb2('00_read.ipynb', 'read')
basic_export_nb2('01_maker.ipynb', 'maker')
```

</div>

</div>
<div class="codecell" markdown="1">
<div class="input_area" markdown="1">


```
g = exec_new('from nbprocess import maker')
assert g['maker'].ModuleMaker
assert 'ModuleMaker' in g['maker'].__all__
```

</div>

</div>
