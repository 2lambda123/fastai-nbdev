"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[68],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9178:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var a,r=n(7462),o=n(3366),i=(n(7294),n(3905)),s=["components"],l={},p=void 0,c={unversionedId:"read",id:"read",title:"read",description:"- Reading a notebook, and initial bootstrapping for notebook exporting",source:"@site/docs/00_read.md",sourceDirName:".",slug:"/read",permalink:"/read",editUrl:"https://github.com/fastai/nbprocess/tree/main/packages/create-docusaurus/templates/shared/docs/00_read.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"tutorialSidebar",next:{title:"maker",permalink:"/maker"}},d={},u=[{value:"Reading and executing notebooks",id:"reading-and-executing-notebooks",level:2},{value:"Config",id:"config",level:2},{value:"Exporting a basic module",id:"exporting-a-basic-module",level:2},{value:"Export -",id:"export--",level:2}],m=(a="CodeOutputBlock",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),f={toc:u};function h(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#hide\n#default_exp read\n")),(0,i.kt)("h1",{id:"nbprocessread"},"nbprocess.read"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reading a notebook, and initial bootstrapping for notebook exporting")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\nfrom datetime import datetime\nfrom fastcore.imports import *\nfrom fastcore.foundation import *\nfrom fastcore.utils import *\nfrom fastcore.test import *\nfrom fastcore.script import *\nfrom fastcore.xtras import *\n\nimport ast,functools\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import time,nbclient,tempfile\nfrom IPython.display import Markdown\nfrom pprint import pformat,pprint\n")),(0,i.kt)("h2",{id:"reading-and-executing-notebooks"},"Reading and executing notebooks"),(0,i.kt)("p",null,"A notebook is just a json file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"minimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = minimal_fn.read_json()\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def _display_json(d):\n    "Formatter to reduce vertical space used by JSON display"\n    s = pformat(d, indent=2, width=120, compact=True, sort_dicts=False)\n    return Markdown(f"```python\\n{s}\\n```")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"_display_json(minimal_txt)\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{ 'cells': [ {'cell_type': 'markdown', 'metadata': {}, 'source': ['# A minimal notebook']},\n             { 'cell_type': 'code',\n               'execution_count': 1,\n               'metadata': {},\n               'outputs': [ { 'data': {'text/plain': ['2']},\n                              'execution_count': 1,\n                              'metadata': {},\n                              'output_type': 'execute_result'}],\n               'source': ['# Do some arithmetic\\n', '1+1']},\n             {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': []}],\n  'metadata': { 'kernelspec': {'display_name': 'Python 3 (ipykernel)', 'language': 'python', 'name': 'python3'},\n                'language_info': { 'codemirror_mode': {'name': 'ipython', 'version': 3},\n                                   'file_extension': '.py',\n                                   'mimetype': 'text/x-python',\n                                   'name': 'python',\n                                   'nbconvert_exporter': 'python',\n                                   'pygments_lexer': 'ipython3',\n                                   'version': '3.9.5'}},\n  'nbformat': 4,\n  'nbformat_minor': 4}\n"))),(0,i.kt)("p",null,"The important bit for us is the ",(0,i.kt)("inlineCode",{parentName:"p"},"cells"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"_display_json(minimal_txt['cells'])\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[ {'cell_type': 'markdown', 'metadata': {}, 'source': ['# A minimal notebook']},\n  { 'cell_type': 'code',\n    'execution_count': 1,\n    'metadata': {},\n    'outputs': [{'data': {'text/plain': ['2']}, 'execution_count': 1, 'metadata': {}, 'output_type': 'execute_result'}],\n    'source': ['# Do some arithmetic\\n', '1+1']},\n  {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': []}]\n"))),(0,i.kt)("p",null,"The second cell here is a ",(0,i.kt)("inlineCode",{parentName:"p"},"code")," cell, however it contains no outputs, because it hasn't been executed yet. To execute a notebook, we first need to convert it into a format suitable for ",(0,i.kt)("inlineCode",{parentName:"p"},"nbclient")," (which expects some ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," keys to be available as attrs, and some available as regular ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," keys). Normally, ",(0,i.kt)("inlineCode",{parentName:"p"},"nbformat")," is used for this step, but it's rather slow and inflexible, so we'll write our own function based on ",(0,i.kt)("inlineCode",{parentName:"p"},"fastcore"),"'s handy ",(0,i.kt)("inlineCode",{parentName:"p"},"dict2obj"),", which makes all keys available as both attrs ",(0,i.kt)("em",{parentName:"p"},"and")," keys."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\nclass NbCell(AttrDict):\n    def __init__(self, idx, cell):\n        super().__init__(cell)\n        self.idx_ = idx\n        if 'source' in self: self.set_source(self.source)\n\n    def __repr__(self): return self.source\n\n    def set_source(self, source):\n        self.source = ''.join(source)\n        if '_parsed_' in self: del(self['_parsed_'])\n\n    def parsed_(self):\n        if self.cell_type!='code' or self.source[:1]=='%': return\n        if '_parsed_' not in self: self._parsed_ = ast.parse(self.source).body\n        return self._parsed_\n\n    def __hash__(self): return hash(self.source) + hash(self.cell_type)\n    def __eq__(self,o): return self.source==o.source and self.cell_type==o.cell_type\n")),(0,i.kt)("p",null,"We use an ",(0,i.kt)("inlineCode",{parentName:"p"},"AttrDict")," subclass which has some basic functionality for accessing notebook cells."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#export\ndef dict2nb(js):\n    "Convert dict `js` to an `AttrDict`, "\n    nb = dict2obj(js)\n    nb.cells = nb.cells.enumerate().starmap(NbCell)\n    return nb\n')),(0,i.kt)("p",null,"We can now convert our JSON into this ",(0,i.kt)("inlineCode",{parentName:"p"},"nbclient"),"-compatible format..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"minimal = dict2nb(minimal_txt)\n")),(0,i.kt)("p",null,"...and execute it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"nbclient.execute(minimal);\n")),(0,i.kt)("p",null,"One nice feature of the output of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict2nb")," is that we can still use it as a ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),", so ",(0,i.kt)("inlineCode",{parentName:"p"},"_display_json")," still works as before. We can see that the cell has been executed, and the output added back to the ",(0,i.kt)("inlineCode",{parentName:"p"},"nb"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"cell = minimal.cells[1]\nprint(cell)\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# Do some arithmetic\n1+1\n"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"_display_json(cell.outputs)\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[{'output_type': 'execute_result', 'metadata': {}, 'data': {'text/plain': '2'}, 'execution_count': 1}]\n"))),(0,i.kt)("p",null,"The abstract syntax tree of source code cells is available in the ",(0,i.kt)("inlineCode",{parentName:"p"},"parsed_")," property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"cell.parsed_()\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[<ast.Expr at 0x7f15e40e68e0>]\n"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"cell.parsed_()[0].value.op\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<ast.Add at 0x7f161dc2a730>\n"))),(0,i.kt)("p",null,"Since loading JSON and converting to an NB is something we'll do a lot, we'll create a shortcut function for it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#export\ndef read_nb(path):\n    "Return notebook at `path`"\n    return dict2nb(Path(path).read_json())\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"minimal = read_nb(minimal_fn)\nprint(minimal.cells[0])\n")),(0,i.kt)(m,{lang:"python",mdxType:"CodeOutputBlock"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# A minimal notebook\n"))),(0,i.kt)("h2",{id:"config"},"Config"),(0,i.kt)("p",null,"nbprocess uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"settings.ini")," file in the root of the project to store all configuration details. This file is in ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigParser")," format, and can be read and written conveniently using fastcore's ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\n@call_parse\ndef nbprocess_create_config(\n    user:str, # Repo username\n    lib_name:str=None, # Name of library\n    description='TODO fill me in', # Description for pypi\n    author='TODO fill me in', # Author for pypi\n    author_email='todo@example.org', # Email for pypi\n    path:str='.', # Path to create config file\n    cfg_name:str='settings.ini', # Name of config file to create\n    branch:str='master', # Repo branch\n    host:str='github', # Repo hostname\n    git_url:str=\"https://github.com/%(user)s/%(lib_name)s/tree/%(branch)s/\", # Repo URL\n    custom_sidebar:bool_arg=False, # Create custom sidebar?\n    nbs_path:str='.', # Name of folder containing notebooks\n    lib_path:str='%(lib_name)s', # Folder name of root module\n    doc_path:str='docs', # Folder name containing docs\n    tst_flags:str='', # Test flags\n    version:str='0.0.1', # Version number\n    keywords='python', # Keywords for pypi\n    license='apache2', # License for pypi\n    copyright='', # Copyright for pypi, defaults to author from current year\n    status='3', # Status for pypi\n    min_python='3.6', # Minimum python version for pypi\n    audience='Developers', # Audience for pypi\n    language='English' # Language for pypi\n):\n    \"Creates a new config file for `lib_name` and `user` and saves it.\"\n    if lib_name is None:\n        parent = Path.cwd().parent\n        lib_name = parent.parent.name if parent.name=='nbs' else parent.name\n    if not copyright: copyright = f'{datetime.now().year} ownwards, {author}'\n    g = locals()\n    config = {o:g[o] for o in 'host lib_name user branch nbs_path doc_path \\\n        description author author_email keywords license tst_flags version custom_sidebar \\\n        copyright status min_python audience language git_url lib_path'.split()}\n    save_config_file(Path(path)/cfg_name, config)\n")),(0,i.kt)("p",null,"This is a wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"fastcore"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"save_config_file")," which sets some ",(0,i.kt)("inlineCode",{parentName:"p"},"nbprocess")," defaults. It is also installed as a CLI command."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\n@functools.lru_cache(maxsize=None)\ndef get_config(cfg_name='settings.ini', path=None):\n    \"`Config` for ini file found in `path` (defaults to `cwd`)\"\n    cfg_path = Path.cwd() if path is None else path\n    while cfg_path != cfg_path.parent and not (cfg_path/cfg_name).exists(): cfg_path = cfg_path.parent\n    return Config(cfg_path, cfg_name=cfg_name)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"get_config")," searches for ",(0,i.kt)("inlineCode",{parentName:"p"},"settings.ini")," in the current directory, and then in all parent directories, stopping when it is found."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"nbprocess_create_config('fastai', path='..', nbs_path='nbs', tst_flags='tst', cfg_name='test_settings.ini')\ncfg = get_config('test_settings.ini')\ntest_eq(cfg.lib_name, 'nbprocess')\ntest_eq(cfg.git_url, \"https://github.com/fastai/nbprocess/tree/master/\")\ncwd = Path.cwd()\ntest_eq(cfg.config_path, cwd.parent.absolute())\ntest_eq(cfg.path('lib_path'), cwd.parent/'nbprocess')\ntest_eq(cfg.path('nbs_path'), cwd)\ntest_eq(cfg.path('doc_path'), cwd.parent/'docs')\n")),(0,i.kt)("h2",{id:"exporting-a-basic-module"},"Exporting a basic module"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\n_init = '__init__.py'\n\ndef _has_py(fs): return any(1 for f in fs if f.endswith('.py'))\n\ndef add_init(path):\n    \"Add `__init__.py` in all subdirs of `path` containing python files if it's not there already\"\n    # we add the lowest-level `__init__.py` files first, which ensures _has_py succeeds for parent modules\n    path = Path(path)\n    path.mkdir(exist_ok=True)\n    if not (path/_init).exists(): (path/_init).touch()\n    for r,ds,fs in os.walk(path, topdown=False):\n        r = Path(r)\n        subds = (os.listdir(r/d) for d in ds)\n        if _has_py(fs) or any(filter(_has_py, subds)) and not (r/_init).exists(): (r/_init).touch()\n")),(0,i.kt)("p",null,"Python modules require a ",(0,i.kt)("inlineCode",{parentName:"p"},"__init.py__")," file in all directories that are modules. We assume that all directories containing a python file (including in subdirectories of any depth) is a module, and therefore add a ",(0,i.kt)("inlineCode",{parentName:"p"},"__init__.py")," to each."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"with tempfile.TemporaryDirectory() as d:\n    d = Path(d)\n    (d/'a/b').mkdir(parents=True)\n    (d/'a/b/f.py').touch()\n    (d/'a/c').mkdir()\n    add_init(d)\n    assert not (d/'a/c'/_init).exists(), \"Should not add init to dir without py file\"\n    for e in [d, d/'a', d/'a/b']: assert (e/_init).exists(),f\"Missing init in {e}\"\n")),(0,i.kt)("h2",{id:"export--"},"Export -"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef write_cells(cells, hdr, file, offset=0):\n    \"Write `cells` to `file` along with header `hdr` starting at index `offset` (mainly for nbprocess internal use)\"\n    for cell in cells:\n        if cell.source.strip(): file.write(f'\\n\\n{hdr} {cell.idx_+offset}\\n{cell}')\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef basic_export_nb(fname, name, dest=None):\n    \"Basic exporter to bootstrap nbprocess\"\n    if dest is None: dest = get_config().path('lib_path')\n    fname,dest = Path(fname),Path(dest)\n    nb = read_nb(fname)\n\n    # grab the source from all the cells that have an `export` comment\n    cells = L(cell for cell in nb.cells if re.match(r'#\\s*export', cell.source))\n\n    # find all the exported functions, to create `__all__`:\n    trees = cells.map(NbCell.parsed_).concat()\n    funcs = trees.filter(risinstance((ast.FunctionDef,ast.ClassDef))).attrgot('name')\n    exp_funcs = [f for f in funcs if f[0]!='_']\n\n    # write out the file\n    with (dest/name).open('w') as f:\n        f.write(f\"# %% auto 0\\n__all__ = {exp_funcs}\")\n        write_cells(cells, f\"# %% {fname.relpath(dest)}\", f)\n        f.write('\\n')\n")),(0,i.kt)("p",null,"This is a simple exporter with just enough functionality to correctly export this notebook, in order to bootstrap the creation of nbprocess itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"#skip\npath = Path('../nbprocess')\n(path/'read.py').unlink(missing_ok=True)\n\nadd_init(path)\nbasic_export_nb(\"00_read.ipynb\", 'read.py')\n\ng = exec_new('from nbprocess import read')\nassert g['read'].add_init\nassert 'add_init' in g['read'].__all__\n")))}h.isMDXComponent=!0}}]);