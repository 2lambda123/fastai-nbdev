"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[689],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(t),d=o,b=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return t?r.createElement(b,s(s({ref:n},c),{},{components:t})):r.createElement(b,s({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1886:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return m}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),s=["components"],i={},l=void 0,p={unversionedId:"sync",id:"sync",title:"sync",description:"Propagating small changes in the library back to notebooks",source:"@site/docs/03_sync.md",sourceDirName:".",slug:"/sync",permalink:"/sync",editUrl:"https://github.com/fastai/nbprocess/tree/main/packages/create-docusaurus/templates/shared/docs/03_sync.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"export",permalink:"/export"},next:{title:"merge",permalink:"/merge"}},c={},m=[{value:"Export -",id:"export--",level:2}],u={toc:m};function d(e){var n=e.components,t=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#default_exp sync\n")),(0,a.kt)("h1",{id:"synchronize-and-diff"},"Synchronize and diff"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Propagating small changes in the library back to notebooks")),(0,a.kt)("p",null,"The library is primarily developed in notebooks so any big changes should be made there. But sometimes, it's easier to fix small bugs or typos in the modules directly. ",(0,a.kt)("inlineCode",{parentName:"p"},"nbprocess_update_lib")," is the function that will propagate those changes back to the corresponding notebooks. Note that you can't create new cells or reorder cells with that functionality, so your corrections should remain limited."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\nfrom nbprocess.imports import *\nfrom nbprocess.read import *\nfrom nbprocess.maker import *\nfrom nbprocess.export import *\n\nfrom fastcore.script import *\nfrom fastcore.xtras import *\n\nimport ast,tempfile,json\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef nb2dict(d, k=None):\n    \"Convert parsed notebook to `dict`\"\n    if k in ('source',): return d.splitlines(keepends=True)\n    if isinstance(d, (L,list)): return list(L(d).map(nb2dict))\n    if not isinstance(d, dict): return d\n    return dict(**{k:nb2dict(v,k) for k,v in d.items() if k[-1] != '_'})\n")),(0,a.kt)("p",null,"This returns the exact same dict as is read from the notebook JSON."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"minimal_fn = Path('../tests/minimal.ipynb')\nminimal = read_nb(minimal_fn)\n\nminimal_dict = minimal_fn.read_json()\nassert minimal_dict==nb2dict(minimal)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef write_nb(nb, path):\n    \"Write `nb` to `path`\"\n    if isinstance(nb, (AttrDict,L)): nb = nb2dict(nb)\n    with maybe_open(path, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(nb, sort_keys=True, indent=1, ensure_ascii=False))\n        f.write(\"\\n\")\n")),(0,a.kt)("p",null,"This returns the exact same string as saved by Jupyter."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"tmp = Path('tmp.ipynb')\ntry:\n    minimal_txt = minimal_fn.read_text()\n    write_nb(minimal, tmp)\n    assert minimal_txt==tmp.read_text()\nfinally: tmp.unlink()\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef absolute_import(name, fname, level):\n    \"Unwarps a relative import in `name` according to `fname`\"\n    if not level: return name\n    mods = fname.split(os.path.sep)\n    if not name: return '.'.join(mods)\n    return '.'.join(mods[:len(mods)-level+1]) + f\".{name}\"\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"test_eq(absolute_import('xyz', 'nbprocess', 0), 'xyz')\ntest_eq(absolute_import('', 'nbprocess', 1), 'nbprocess')\ntest_eq(absolute_import('core', 'nbprocess', 1), 'nbprocess.core')\ntest_eq(absolute_import('core', 'nbprocess/vision', 2), 'nbprocess.core')\ntest_eq(absolute_import('transform', 'nbprocess/vision', 1), 'nbprocess.vision.transform')\ntest_eq(absolute_import('notebook.core', 'nbprocess/data', 2), 'nbprocess.notebook.core')\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'#export\n_re_import = re.compile("from\\s+\\S+\\s+import\\s+\\S")\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#hide\nassert _re_import.match('from foo import bar')\nassert not _re_import.match('#from foo import bar')\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef _to_absolute(code, lib_name):\n    if not _re_import.search(code): return code\n    res = update_import(code, ast.parse(code).body, lib_name, absolute_import)\n    return ''.join(res) if res else code\n\ndef _update_lib(nbname, nb_locs, lib_name=None):\n    if lib_name is None: lib_name = get_config().lib_name\n    # Too avoid overwriting the comments\n    nbp = NBProcessor(nbname, ExportModuleProc())\n    nb = nbp.nb\n    nbp.process()\n\n    for name,idx,code in nb_locs:\n        assert name==nbname\n        cell = nb.cells[int(idx)-1]\n        lines = cell.source.splitlines(True)\n        source = ''.join(cell.source.splitlines(True)[:len(cell._comments)])\n        cell.source = source + _to_absolute(code, lib_name)\n    write_nb(nb, nbname)\n\ndef _get_call(s):\n    top,*rest = s.splitlines()\n    return *top.split(),'\\n'.join(rest)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#export\n@call_parse\ndef update_lib(fname:str): # A python file name to convert\n    \"Propagates any change in the modules matching `fname` to the notebooks that created them\"\n    if os.environ.get('IN_TEST',0): return\n    code_cells = Path(fname).read_text().split(\"\\n# %% \")[1:]\n    locs = L(_get_call(s) for s in code_cells if not s.startswith('auto '))\n    for nbname,nb_locs in groupby(locs, 0).items(): _update_lib(nbname, nb_locs)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# hide\n# update_lib("../nbprocess/sync.py")\n')),(0,a.kt)("h2",{id:"export--"},"Export -"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"#skip\nfrom nbprocess.export import nbs_export\nnbs_export()\n")))}d.isMDXComponent=!0}}]);