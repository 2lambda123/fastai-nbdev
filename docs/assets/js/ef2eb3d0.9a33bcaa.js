"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[855],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return f}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=r.createContext({}),i=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=i(e.components);return r.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,p=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),u=i(t),f=o,d=u["".concat(p,".").concat(f)]||u[f]||m[f]||s;return t?r.createElement(d,l(l({ref:n},c),{},{components:t})):r.createElement(d,l({ref:n},c))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,l=new Array(s);l[0]=u;var a={};for(var p in n)hasOwnProperty.call(n,p)&&(a[p]=n[p]);a.originalType=e,a.mdxType="string"==typeof e?e:o,l[1]=a;for(var i=2;i<s;i++)l[i]=t[i];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8413:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return i},default:function(){return _},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return u}});var r,o=t(7462),s=t(3366),l=(t(7294),t(3905)),a=["components"],p={},i=void 0,c={unversionedId:"export",id:"export",title:"export",description:"- Exporting a notebook to a library",source:"@site/docs/02_export.md",sourceDirName:".",slug:"/export",permalink:"/export",editUrl:"https://github.com/fastai/nbprocess/tree/main/packages/create-docusaurus/templates/shared/docs/02_export.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"maker",permalink:"/maker"},next:{title:"sync",permalink:"/sync"}},m={},u=[{value:"NBProcessor -",id:"nbprocessor--",level:2},{value:"Output processors -",id:"output-processors--",level:2},{value:"ExportModuleProc -",id:"exportmoduleproc--",level:2},{value:"Export -",id:"export--",level:2}],f=(r="CodeOutputBlock",function(e){return console.warn("Component "+r+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",e)}),d={toc:u};function _(e){var n=e.components,t=(0,s.Z)(e,a);return(0,l.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#hide\n#default_exp export\n")),(0,l.kt)("h1",{id:"nbprocessexport"},"nbprocess.export"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Exporting a notebook to a library")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\nfrom nbprocess.read import *\nfrom nbprocess.maker import *\nfrom nbprocess.imports import *\n\nfrom fastcore.script import *\nfrom fastcore.imports import *\nfrom fastcore.xtras import *\n\nfrom collections import defaultdict\nfrom pprint import pformat\nfrom inspect import signature,Parameter\nimport ast,contextlib,copy\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from fastcore.test import *\nfrom pdb import set_trace\nfrom importlib import reload\nimport shutil\n")),(0,l.kt)("h2",{id:"nbprocessor--"},"NBProcessor -"),(0,l.kt)("p",null,"Special comments at the start of a cell can be used to provide information to ",(0,l.kt)("inlineCode",{parentName:"p"},"nbprocess")," about how to process a cell, so we need to be able to find the location of these comments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"minimal = read_nb('../tests/minimal.ipynb')\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef extract_comments(ss):\n    \"Take leading comments from lines of code in `ss`, remove `#`, and split\"\n    ss = ss.splitlines()\n    first_code = first(i for i,o in enumerate(ss) if not o.strip() or re.match('\\s*[^#\\s]', o))\n    return L((s.strip()[1:]).strip().split() for s in ss[:first_code]).filter()\n")),(0,l.kt)("p",null,"nbprocess comments start with ",(0,l.kt)("inlineCode",{parentName:"p"},"#"),", followed by whitespace delimited tokens, which ",(0,l.kt)("inlineCode",{parentName:"p"},"extract_comments")," extracts from the start of a cell, up until a blank line or a line containing something other than comments:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"exp  = \"\"\"#export module\n# hide\n1+2\n#bar\"\"\"\ntest_eq(extract_comments(exp), [['export', 'module'],['hide']])\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'#export\n@functools.lru_cache(maxsize=None)\ndef _param_count(f):\n    "Number of parameters accepted by function `f`"\n    params = list(signature(f).parameters.values())\n    # If there\'s a `*args` then `f` can take as many params as needed\n    if first(params, lambda o: o.kind==Parameter.VAR_POSITIONAL): return 99\n    return len([o for o in params if o.kind in (Parameter.POSITIONAL_ONLY,Parameter.POSITIONAL_OR_KEYWORD)])\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\nclass NBProcessor:\n    \"Process cells and nbdev comments in a notebook\"\n    def __init__(self, path=None, procs=None, outp_procs=None, nb=None, debug=False):\n        self.nb = read_nb(path) if nb is None else nb\n        self.procs,self.outp_procs,self.debug = L(procs),L(outp_procs),debug\n\n    def _process_cell(self, cell):\n        self.cell = cell\n        cell._comments = extract_comments(cell.source)\n        for proc in self.procs:\n            if callable(proc): proc(cell)\n            if cell.cell_type=='code': cell._comments.map(self._process_comment,proc)\n        for proc in self.outp_procs: L(cell.get('outputs', [])).map(proc, cell)\n\n    def _process_comment(self, proc, comment):\n        cmd,*args = comment\n        f = getattr(proc, f'_{cmd}_', None)\n        if not f or _param_count(f)-1<len(args): return True\n        if self.debug: print(cmd, args, f)\n        return f(self, *args)\n        \n    def process(self):\n        \"Process all cells with `process_cell`\"\n        for i in range_of(self.nb.cells): self._process_cell(self.nb.cells[i])\n        self.nb.cells = [c for c in self.nb.cells if c.source is not None]\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class _PrintExample:\n    def _printme_(self, nbp, to_print): print(to_print)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"everything_fn = '../tests/01_everything.ipynb'\nproc = NBProcessor(everything_fn, _PrintExample())\nproc.process()\n")),(0,l.kt)(f,{lang:"python",mdxType:"CodeOutputBlock"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"testing\n"))),(0,l.kt)("h2",{id:"output-processors--"},"Output processors -"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\nclass outp_proc:\n    \"Decorator for funcs to pass to `NBProcessor` for processing cell output\"\n    def __init__(self, *idxs): self.idxs = idxs\n    def __call__(self, func):\n        def _inner(cell, outp):\n            item = nested_idx(outp, *self.idxs)\n            if not item: return\n            res = func(cell, outp, ''.join(item))\n            if res is not None: set_nested_idx(outp, res.splitlines(True), *self.idxs)\n        return _inner\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\n_re_ansi_escape = re.compile(r'\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])')\n\n@outp_proc('text')\ndef strip_ansi(cell, outp, item):\n    \"Output processor to strip Ansi Characters\"\n    if outp.get('name') == 'stdout': return _re_ansi_escape.sub('', item)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"proc = NBProcessor(everything_fn, outp_procs=strip_ansi)\nproc.process()\n\ndef _valid(o): return not o or not _re_ansi_escape.search(o)\nfor cell in proc.nb.cells:\n    assert all(_valid(nested_idx(o, 'text', 0)) for o in cell.get('outputs', []))\n")),(0,l.kt)("h2",{id:"exportmoduleproc--"},"ExportModuleProc -"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\nclass ExportModuleProc:\n    \"A processor which exports code to a module\"\n    def __init__(self): self.modules,self.in_all = defaultdict(L),defaultdict(L)\n    def _default_exp_(self, nbp, exp_to): self.default_exp = exp_to\n    def _exporti_(self, nbp, exp_to=None): self.modules[ifnone(exp_to, '#')].append(nbp.cell)\n    def _export_(self, nbp, exp_to=None):\n        self._exporti_(nbp, exp_to)\n        self.in_all[ifnone(exp_to, '#')].append(nbp.cell)\n")),(0,l.kt)("p",null,"Specify ",(0,l.kt)("inlineCode",{parentName:"p"},"dest")," where the module(s) will be exported to, and optionally a class to use to create the module (",(0,l.kt)("inlineCode",{parentName:"p"},"ModuleMaker"),", by default)."),(0,l.kt)("p",null,"Exported cells are stored in a ",(0,l.kt)("inlineCode",{parentName:"p"},"dict")," called ",(0,l.kt)("inlineCode",{parentName:"p"},"modules"),", where the keys are the modules exported to. Those without an explicit module are stored in the ",(0,l.kt)("inlineCode",{parentName:"p"},"'#'")," key, which will be exported to ",(0,l.kt)("inlineCode",{parentName:"p"},"default_exp"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"exp = ExportModuleProc()\nproc = NBProcessor(everything_fn, exp)\nproc.process()\ntest_eq(exp.default_exp, 'everything')\nassert 'print_function'  in exp.modules['#'][0].source\nassert 'h_n' in exp.in_all['some.thing'][0].source\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef rm_comments_proc(cell):\n    \"A proc that removes comments from each NB cell source\"\n    cell.source = ''.join(cell.source.splitlines(True)[len(cell._comments):])\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef create_modules(path, dest, procs=None, debug=False, mod_maker=ModuleMaker):\n    \"Create module(s) from notebook\"\n    exp = ExportModuleProc()\n    nb = NBProcessor(path, [exp,rm_comments_proc]+L(procs), debug=debug)\n    nb.process()\n    for mod,cells in exp.modules.items():\n        all_cells = exp.in_all[mod]\n        name = exp.default_exp if mod=='#' else mod\n        mm = mod_maker(dest=dest, name=name, nb_path=path, is_new=mod=='#')\n        mm.make(cells, all_cells)\n")),(0,l.kt)("p",null,"Let's check we can import a test file:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"shutil.rmtree('tmp', ignore_errors=True)\ncreate_modules('../tests/00_some.thing.ipynb', 'tmp')\n\ng = exec_new('import tmp.some.thing')\ntest_eq(g['tmp'].some.thing.__all__, ['a'])\ntest_eq(g['tmp'].some.thing.a, 1)\n")),(0,l.kt)("p",null,"We'll also check that our 'everything' file exports correctly:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'create_modules(everything_fn, \'tmp\')\n\ng = exec_new(\'import tmp.everything; from tmp.everything import *\')\n_alls = L("a b d e m n o p q".split())\nfor s in _alls.map("{}_y"): assert s in g, s\nfor s in "c_y_nall _f_y_nall g_n h_n i_n j_n k_n l_n".split(): assert s not in g, s\nfor s in _alls.map("{}_y") + ["c_y_nall", "_f_y_nall"]: assert hasattr(g[\'tmp\'].everything,s), s\n')),(0,l.kt)("p",null,"That notebook should also export one extra function to ",(0,l.kt)("inlineCode",{parentName:"p"},"tmp.some.thing"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"del(sys.modules['tmp.some.thing']) # remove from module cache\ng = exec_new('import tmp.some.thing')\ntest_eq(g['tmp'].some.thing.__all__, ['a','h_n'])\ntest_eq(g['tmp'].some.thing.h_n(), None)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\ndef nb_export(nbname, lib_name=None):\n    if lib_name is None: lib_name = get_config().lib_name\n    create_modules(nbname, lib_name)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#export\n@call_parse\ndef nbs_export(\n    path:str='.', # path or filename\n    recursive:bool=True, # search subfolders\n    symlinks:bool=True, # follow symlinks?\n    file_glob:str='*.ipynb', # Only include files matching glob\n    file_re:str=None, # Only include files matching regex\n    folder_re:str=None, # Only enter folders matching regex\n    skip_file_glob:str=None, # Skip files matching glob\n    skip_file_re:str=None, # Skip files matching regex\n    skip_folder_re:str='^[_.]' # Skip folders matching regex\n):\n    if os.environ.get('IN_TEST',0): return\n    if not recursive: skip_folder_re='.'\n    files = globtastic(path, symlinks=symlinks, file_glob=file_glob, file_re=file_re,\n        folder_re=folder_re, skip_file_glob=skip_file_glob, skip_file_re=skip_file_re, skip_folder_re=skip_folder_re)\n    files.map(nb_export)\n")),(0,l.kt)("h2",{id:"export--"},"Export -"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"#skip\nPath('../nbprocess/export.py').unlink(missing_ok=True)\nnbs_export()\n\ng = exec_new('import nbprocess.export')\nassert hasattr(g['nbprocess'].export, 'nb_export')\n")))}_.isMDXComponent=!0}}]);